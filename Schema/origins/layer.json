{
	"$id": "https://raw.githubusercontent.com/WACriminalG2/PackdevUtils/main/Schema/origins/layer.json",
	"$schema": "http://json-schema.org/draft-07/schema#",
	"title": "Origins layer JSON schema by S_K_Tiger",
	"description": "See: https://origins.readthedocs.io/en/latest/layer_json/ if you have any questions.\nFound any mistakes? Open a issue at https://github.com/WACriminalG2/PackdevUtils/issues",
	"type": "object",
	"properties": {
		"order": {
			"type": "integer",
			"description": "Specifies the order of this layer in the choose and view origin screen among the other layers. Smaller numbers mean it appears before layers with larger numbers."
		},
		"origins": {
			"type": "array",
			"description": "Defines the origins that should be in this layer. Identifier strings and Conditioned Origin objects can be mixed in the same array.",
			"items": {
				"type": ["string", "object"],
				"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$",
				"properties": {
					"condition": { "$ref": "#/definitions/conditions/properties/entity_condition" },
					"origins": {
						"type": "array",
						"description": "IDs of the origins which should become available when the condition is fulfilled.",
						"items": {
							"type": "string",
							"description": "Identifier string",
							"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$"
						}
					}
				},
				"required": [ "condition", "origins" ]
			}
		},
		"enabled": {
			"type": "boolean",
			"description": "If set to false, this layer will be unavailable.",
			"default": true
		},
		"replace": {
			"type": "boolean",
			"description": "If set to false, the data in this file will be appended to an already existing version of this layer. Useful to add custom origins to the default origin layer for example. If set to true, the layer will be replaced and only the origins specified in this file will appear.",
			"default": false
		},
		"name": {
			"type": "string",
			"description": "The display name of the layer. Will show at the top of the GUI saying \"Choose your [name here]\". Can be a literal string or a translation key."
		},
		"missing_name": {
			"type": "string",
			"description": "The display name of the origin that will show when viewing the origin if no origin has been assigned to this layer. Can be a literal string or a translation key."
		},
		"missing_description": {
			"type": "string",
			"description": "The description of the origin that will show when viewing the origin if no origin has been assigned to this layer. Can be a literal string or a translation key."
		},
		"allow_random": {
			"type": "boolean",
			"description": "If set to true, this layer will show an option for choosing a random origin.",
			"default": false
		},
		"allow_random_unchoosable": {
			"type": "boolean",
			"description": "Whether origins which are unchoosable (unchoosable field set to true in the origin file) should be included in the random option. Can for example be used to force players to choose a random origin, by setting this to true and making all origins in the layer unchoosable.",
			"default": false
		},
		"exclude_random": {
			"type": "array",
			"description": "If specified, the origins included in this list will not be picked by the random choice.",
			"items": {
				"type": "string",
				"description": "Identifier string",
				"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$"
			}
		},
		"default_origin": {
			"type": "string",
			"description": "If set, the origin with this ID will automatically be chosen for a new player. If an orb of origin is used later on, the player will be able to choose another origin then and the default_origin will not apply. Could for example be used to make all players start as human, and then use the orb as a progression item to select an origin.",
			"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$"
		},
		"auto_choose": {
			"type": "boolean",
			"description": "If set to true, this layer will automatically pick an origin for the player if only one option is available. This also applies when an orb of origin is used.",
			"default": false
		}
	},
	"required": [ "origins" ],
	"definitions": {
		"conditions": {
			"type": "object",
			"description": "Group for conditions",
			"properties": {
				"bientity_condition": {
					"type": "object",
					"description": "Bi-entity Conditions operate on a Pair<Entity, Entity>, or in simpler terms: an actor and a target. The actor and target is determined depending on the used power type, and can be swapped. These are available to power types that provides a bientity_condition field, which restricts when a power is active.",
					"properties": {
						"type": {
							"type": "string",
							"description": "ID of the advancement the player needs to have completed in order for this condition to evaluate to true.",
							"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$",
							"examples": [
								"origins:and", "origins:or", "origins:constant",
								"origins:actor_condition", "origins:attack_target", "origins:attacker", "origins:both", "origins:can_see",
								"origins:distance", "origins:either", "origins:invert", "origins:owner", "origins:riding_recursive",
								"origins:riding_root", "origins:riding", "origins:target_condition"
							]
						},
						"inverted": {
							"type": "boolean",
							"description": "If true, the condition acts inverted.",
							"default": false
						}
					},
					"required": [ "type" ],
					"allOf": [
						{
							"$comment": "#region meta",
							"if": {
								"properties": { "type": { "const": "origins:and" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"conditions": {
										"type": "array",
										"description": "All of these conditions have to be fulfilled in order for this condition to be fulfilled.",
										"items": { "$ref": "#/definitions/conditions/properties/bientity_condition" },
										"minItems": 1
									}
								},
								"required": [ "conditions" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:or" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"conditions": {
										"type": "array",
										"description": "Any of these conditions have to be fulfilled in order for this condition to be fulfilled.",
										"items": { "$ref": "#/definitions/conditions/properties/bientity_condition" },
										"minItems": 1
									}
								},
								"required": [ "conditions" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:constant" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"value": {
										"type": "boolean",
										"description": "If true, the condition is always fulfilled. If false, the condition is never fulfilled."
									}
								},
								"required": [ "value" ]
							},
							"$comment": "#endregion meta"
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:actor_condition" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"condition": {
										"$ref": "#/definitions/conditions/properties/entity_condition",
										"description": "The condition to check for on the acting entity."
									}
								},
								"required": [ "condition" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:both" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"condition": {
										"$ref": "#/definitions/conditions/properties/entity_condition",
										"description": "The condition to check on both the actor and target entity."
									}
								},
								"required": [ "condition" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:distance" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"comparison": {
										"description": "How to compare the distance against the specified value.",
										"enum": [ "<", "<=", ">", ">=", "==", "!=" ]
									},
									"compare_to": {
										"type": "number",
										"description": "The distance (in blocks) to compare the distance between the actor and target to."
									}
								},
								"required": [ "comparison", "compare_to" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:either" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"condition": {
										"$ref": "#/definitions/conditions/properties/entity_condition",
										"description": "The condition to check on either actor or target entities."
									}
								},
								"required": [ "condition" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:invert" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"bientity_condition": {
										"$ref": "#/definitions/conditions/properties/bientity_condition",
										"description": "The bi-entity condition to check which will have its 'target' and 'actor' contexts swapped."
									}
								},
								"required": [ "bientity_condition" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:target_condition" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"condition": {
										"$ref": "#/definitions/conditions/properties/entity_condition",
										"description": "The condition to check for on the target entity."
									}
								},
								"required": [ "condition" ]
							}
						}
					]
				},
				"biome_condition": {
					"type": "object",
					"description": "Biome Conditions operate on a Biome.",
					"properties": {
						"type": {
							"type": "string",
							"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$",
							"examples": [
								"origins:and", "origins:or", "origins:constant",
								"origins:category", "origins:high_humidity", "origins:precipitation", "origins:temperature"
							]
						},
						"inverted": {
							"type": "boolean",
							"description": "If true, the condition acts inverted.",
							"default": false
						}
					},
					"required": [ "type" ],
					"allOf": [
						{
							"$comment": "#region meta",
							"if": {
								"properties": { "type": { "const": "origins:and" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"conditions": {
										"type": "array",
										"description": "All of these conditions have to be fulfilled in order for this condition to be fulfilled.",
										"items": { "$ref": "#/definitions/conditions/properties/biome_condition" },
										"minItems": 1
									}
								},
								"required": [ "conditions" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:or" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"conditions": {
										"type": "array",
										"description": "Any of these conditions have to be fulfilled in order for this condition to be fulfilled.",
										"items": { "$ref": "#/definitions/conditions/properties/biome_condition" },
										"minItems": 1
									}
								},
								"required": [ "conditions" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:constant" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"value": {
										"type": "boolean",
										"description": "If true, the condition is always fulfilled. If false, the condition is never fulfilled."
									}
								},
								"required": ["value"]
							},
							"$comment": "#endregion meta"
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:category" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"category": {
										"$comment": "Note: Categories may change after 1.17",
										"type": "string",
										"description": "Which category the biome must be in order to succeed the check. See https://origins.readthedocs.io/en/latest/misc/biome_categories/.",
										"examples": [
											"beach", "desert", "extreme_hills", "forest", "icy", "jungle", "mesa", "mushroom",
											"nether", "none", "ocean", "plains", "river", "savanna", "swamp", "taiga", "the_end"
										]
									}
								},
								"required": ["category"]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:precipitation" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"precipitation": {
										"description": "Which precipitation the biome has to have in order to succeed the check. One of none, rain and snow.",
										"enum": [ "none", "rain", "snow" ]
									}
								},
								"required": [ "precipitation" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:temperature" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"comparison": {
										"description": "How the temperature should be compared to the specified value.",
										"enum": [ "<", "<=", ">", ">=", "==", "!=" ]
									},
									"compare_to": {
										"type": "number",
										"description": "Which value the temperature should be compared to."
									}
								},
								"required": [ "comparison", "compare_to" ]
							}
						}
					]
				},
				"block_condition": {
					"type": "object",
					"description": "Block Conditions operate on CachedBlockPosition, essentially a combination of World and BlockPos, which allows retrieving all necessary information about the block.",
					"properties": {
						"type": {
							"type": "string",
							"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$",
							"examples": [
								"origins:and", "origins:or", "origins:constant",
								"origins:adjacent", "origins:attachable", "origins:block", "origins:block_state",
								"origins:exposed_to_sky", "origins:fluid", "origins:height", "origins:in_tag", "origins:light_blocking",
								"origins:light_level", "origins:movement_blocking", "origins:offset", "origins:replacable",
								"origins:water_loggable"
							]
						},
						"inverted": {
							"type": "boolean",
							"description": "If true, the condition acts inverted.",
							"default": false
						}
					},
					"required": [ "type" ],
					"allOf": [
						{
							"$comment": "#region meta",
							"if": {
								"properties": { "type": { "const": "origins:and" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"conditions": {
										"type": "array",
										"description": "All of these conditions have to be fulfilled in order for this condition to be fulfilled.",
										"items": { "$ref": "#/definitions/conditions/properties/block_condition" },
										"minItems": 1
									}
								},
								"required": [ "conditions" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:or" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"conditions": {
										"type": "array",
										"description": "Any of these conditions have to be fulfilled in order for this condition to be fulfilled.",
										"items": { "$ref": "#/definitions/conditions/properties/block_condition" },
										"minItems": 1
									}
								},
								"required": [ "conditions" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:constant" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"value": {
										"type": "boolean",
										"description": "If true, the condition is always fulfilled. If false, the condition is never fulfilled."
									}
								},
								"required": [ "value" ]
							},
							"$comment": "#endregion meta"
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:adjacent" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"adjacent_condition": {
										"$ref": "#/definitions/conditions/properties/block_condition",
										"description": "The block condition that needs to be fulfilled by adjacent blocks to count towards this condition."
									},
									"comparison": {
										"description": "How the number of adjacent blocks which fulfill adjacent_condition should be compared to the specified value.",
										"enum": [ "<", "<=", ">", ">=", "==", "!=" ]
									},
									"compare_to": {
										"type": "number",
										"description": "The value to compare the number to."
									}
								},
								"required": [ "adjacent_condition", "comparison", "compare_to" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:block" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"block": {
										"type": "string",
										"description": "ID of the block that this block needs to be to pass the check.",
										"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$",
										"examples": [ "minecraft:diamond_block", "minecraft:emerald_block" ]
									}
								},
								"required": [ "block" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:block_state" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"property": {
										"type": "string",
										"description": "The name of the property that should be checked. See: https://minecraft.fandom.com/wiki/Block_states#List_of_block_states",
										"examples": [ "facing", "age", "leaves", "stage", "rotation", "open", "occupied", "part", "honey_level", "attachment", "powered" ]
									},
									"comparison": {
										"description": "If the property contains an integer value, this is the comparison the will be used to compare the property's value to the specified compare_to integer.",
										"enum": [ "<", "<=", ">", ">=", "==", "!=" ]
									},
									"compare_to": {
										"type": "integer",
										"description": "If the property contains an integer value, this is the value the property's value will be compared to."
									},
									"value": {
										"type": "boolean",
										"description": "If the property contains a boolean value, this is the value the property needs to be to pass the check."
									},
									"enum": {
										"type": "string",
										"description": "If the property contains different string values, this is the string value the property needs to be to pass the check."
									}
								},
								"required": [ "property" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:fluid" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"fluid_condition": {
										"$ref": "#/definitions/conditions/properties/fluid_condition",
										"description": "The fluid condition to check the fluid state at the position."
									}
								},
								"required": [ "fluid_condition" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:height" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"comparison": {
										"description": "How the Y position of the block should be compared to the specified value.",
										"enum": [ "<", "<=", ">", ">=", "==", "!=" ]
									},
									"compare_to": {
										"type": "number",
										"description": "The value to compare the Y position of the block to."
									}
								},
								"required": [ "comparison", "compare_to" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:in_tag" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"tag": {
										"type": "string",
										"description": "ID of the tag which the block should be in to pass the check.",
										"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$",
										"examples": [ "minecraft:base_stone_overworld" ]
									}
								},
								"required": [ "tag" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:light_level" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"light_type": {
										"description": "The type of light level to compare. Either sky or block. If no type is provided, the greater value of the two types will be used, which is the \"resulting\" light level of that position.",
										"enum": [ "sky", "block" ]
									},
									"comparison": {
										"description": "How the light level should be compared to the specified value.",
										"enum": [ "<", "<=", ">", ">=", "==", "!=" ]
									},
									"compare_to": {
										"type": "integer",
										"description": "The value to compare the light level at the block's position to."
									}
								},
								"required": [ "comparison", "compare_to" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:offset" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"condition": {
										"$ref": "#/definitions/conditions/properties/block_condition",
										"description": "The condition to check with the given offset."
									},
									"x": {
										"type": "integer",
										"description": "How much to offset the position on the x-axis.",
										"default": 0
									},
									"y": {
										"type": "integer",
										"description": "How much to offset the position on the y-axis.",
										"default": 0
									},
									"z": {
										"type": "integer",
										"description": "How much to offset the position on the z-axis.",
										"default": 0
									}
								},
								"required": [ "condition" ]
							}
						}
					]
				},
				"damage_condition": {
					"type": "object",
					"description": "Damage Conditions operate on a combination of DamageSource and Float, allowing to check not only the type of damage dealt, but also how much damage was dealt.",
					"properties": {
						"type": {
							"type": "string",
							"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$",
							"examples": [
								"origins:and", "origins:or", "origins:constant",
								"origins:amount", "origins:attacker", "origins:fire", "origins:name",
								"origins:projectile"
							]
						},
						"inverted": {
							"type": "boolean",
							"default": false,
							"description": "If true, the condition acts inverted."
						}
					},
					"required": [ "type" ],
					"allOf": [
						{
							"$comment": "#region meta",
							"if": {
								"properties": { "type": { "const": "origins:and" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"conditions": {
										"type": "array",
										"description": "All of these conditions have to be fulfilled in order for this condition to be fulfilled.",
										"items": { "$ref": "#/definitions/conditions/properties/damage_condition" },
										"minItems": 1
									}
								},
								"required": [ "conditions" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:or" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"conditions": {
										"type": "array",
										"description": "Any of these conditions have to be fulfilled in order for this condition to be fulfilled.",
										"items": { "$ref": "#/definitions/conditions/properties/damage_condition" },
										"minItems": 1
									}
								},
								"required": [ "conditions" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:constant" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"value": {
										"type": "boolean",
										"description": "If true, the condition is always fulfilled. If false, the condition is never fulfilled."
									}
								},
								"required": [ "value" ]
							},
							"$comment": "#endregion meta"
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:amount" } },
								"require": [ "type" ]
							},
							"then": {
								"properties": {
									"comparison": {
										"description": "How the amount of damage should be compared to the specified value.",
										"enum": [ "<", "<=", ">", ">=", "==", "!=" ]
									},
									"compare_to": {
										"type": "number",
										"description": "The value to compare the amount of damage to."
									}
								},
								"required": [ "comparison", "compare_to" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:attacker" } },
								"require": [ "type" ]
							},
							"then": {
								"properties": {
									"entity_condition": {
										"$ref": "#/definitions/conditions/properties/entity_condition",
										"description": "If set, the attacking entity must fulfill the provided entity condition in order for this condition to evaluate to true."
									}
								}
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:name" } },
								"require": [ "type" ]
							},
							"then": {
								"properties": {
									"name": {
										"type": "string",
										"description": "Name the damage source should have to pass the check. See https://origins.readthedocs.io/en/latest/misc/vanilla_damage_sources/",
										"examples": [
											"anvil", "arrow", "badRespawnPoint", "cactus", "cramming",
											"dragonBreath", "drown", "dryout", "explosion.player",
											"explosion", "fall", "fallingBlock", "fallingStalactite",
											"fireworks", "flyIntoWall", "freeze", "generic", "hotFloor",
											"indirectMagic", "inFire", "inWall", "lava", "lightningBolt",
											"magic", "mob", "onFire", "outOfWorld", "player", "stalagmite",
											"starve", "sting", "sweetBerryBush", "thorns", "thrown",
											"trident", "wither", "witherSkull"
										]
									}
								}
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:projectile" } },
								"require": [ "type" ]
							},
							"then": {
								"properties": {
									"projectile": {
										"type": "string",
										"description": "If set, the check will only pass if the projectile was of an entity type with this ID.",
										"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$",
										"examples": [ "minecraft:spectral_arrow" ]
									}
								}
							}
						}
					]
				},
				"entity_condition": {
					"type": "object",
					"description": "Entity Conditions operate on a LivingEntity, which also allows access to the world. These are available to be used in most powers in the condition field, which restricts when a power is active.",
					"properties": {
						"type": {
							"type": "string",
							"description": "ID of the advancement the player needs to have completed in order for this condition to evaluate to true.",
							"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$",
							"examples": [
								"origins:and", "origins:or", "origins:constant",
								"origins:advancement", "origins:air", "origins:attribute", "origins:biome", "origins:block_collision",
								"origins:block_in_radius", "origins:brightness", "origins:climbing", "origins:collided_horizontally",
								"origins:command", "origins:creative_flying", "origins:daytime", "origins:dimension", "origins:enchantment",
								"origins:entity_group", "origins:entity_type", "origins:equipped_item", "origins:exists",
								"origins:exposed_to_sky", "origins:exposed_to_sun", "origins:fall_distance", "origins:fall_flying",
								"origins:fluid_height", "origins:food_level", "origins:gamemode", "origins:health", "origins:in_block_anywhere",
								"origins:in_block", "origins:in_rain", "origins:in_tag", "origins:invisible", "origins:living",
								"origins:moving", "origins:on_block", "origins:on_fire", "origins:origin", "origins:passenger_recursive",
								"origins:passenger", "origins:power_active","origins:power", "origins:predicate", "origins:relative_health",
								"origins:resource", "origins:riding_recursive", "origins:riding_root", "origins:riding", "origins:saturation_level","origins:scoreboard", "origins:sneaking",
								"origins:sprinting", "origins:status_effect", "origins:submerged_in","origins:swimming", "origins:tamed",
								"origins:using_effective_tool", "origins:using_item", "origins:xp_levels", "origins:xp_points"
							]
						},
						"inverted": {
							"type": "boolean",
							"description": "If true, the condition acts inverted.",
							"default": false
						}
					},
					"required": [ "type" ],
					"allOf": [
						{
							"$comment": "#region meta",
							"if": {
								"properties": { "type": { "const": "origins:and" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"conditions": {
										"type": "array",
										"description": "All of these conditions have to be fulfilled in order for this condition to be fulfilled.",
										"items": { "$ref": "#/definitions/conditions/properties/entity_condition" },
										"minItems": 1
									}
								},
								"required": [ "conditions" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:or" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"conditions": {
										"type": "array",
										"description": "Any of these conditions have to be fulfilled in order for this condition to be fulfilled.",
										"items": { "$ref": "#/definitions/conditions/properties/entity_condition" },
										"minItems": 1
									}
								},
								"required": [ "conditions" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:constant" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"value": {
										"type": "boolean",
										"description": "If true, the condition is always fulfilled. If false, the condition is never fulfilled."
									}
								},
								"required": [ "value" ]
							},
							"$comment": "#endregion meta"
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:advancement" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"advancement": {
										"type": "string",
										"description": "ID of the advancement the player needs to have completed in order for this condition to evaluate to true.",
										"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$",
										"examples": [ "minecraft:story/smelt_iron" ]
									}
								},
								"required": [ "advancement" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:air" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"comparison": {
										"description": "How the breath (in ticks) should be compared to the specified value.",
										"enum": [ "<", "<=", ">", ">=", "==", "!=" ]
									},
									"compare_to": {
										"type": "integer",
										"description": "Which value the breath should be compared to."
									}
								},
								"required": [ "comparison", "compare_to" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:attribute" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"attribute": {
										"type": "string",
										"description": "ID of the attribute of which the value should be checked.",
										"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$",
										"examples": [ "minecraft:generic.armor" ]
									},
									"comparison": {
										"description": "How to compare the attribute's value to the specified value.",
										"enum": [ "<", "<=", ">", ">=", "==", "!=" ]
									},
									"compare_to": {
										"type": "number",
										"description": "Which value to compare the attribute's value to."
									}
								},
								"required": [ "attribute", "comparison", "compare_to" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:biome" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"biome": {
										"type": "string",
										"description": "If set, this is the ID of the biome the player needs to be in for this condition to evaluate to true, e.g. minecraft:savanna.",
										"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$",
										"examples": [ "minecraft:savanna" ]
									},
									"biomes": {
										"type": "array",
										"description": "If set, these are the allowed biome IDs the player can be in for this condition to evaluate to true.",
										"items": {
											"type": "string",
											"description": "If set, this is the ID of the biome the player needs to be in for this condition to evaluate to true, e.g. minecraft:savanna.",
											"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$",
											"examples": [ "minecraft:savanna" ]
										}
									},
									"condition": {
										"$ref": "#/definitions/conditions/properties/biome_condition",
										"description": "If set, this condition needs to be fulfilled (in addition to having the right ID, if provided) by the biome in order for the condition to evaluate to true."
									}
								}
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:block_collision" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"offset_x": {
										"type": "number",
										"description": "By how much of the bounding box size should the box be offset in the X direction (e.g.: 0 = no offset, 1 = offset of exact width, 2 = offset of twice the width of the bounding box)"
									},
									"offset_y": {
										"type": "number",
										"description": "By how much of the bounding box size should the box be offset in the Y direction (e.g.: 0 = no offset, 1 = offset of exact width, 2 = offset of twice the width of the bounding box)"
									},
									"offset_z": {
										"type": "number",
										"description": "By how much of the bounding box size should the box be offset in the Z direction (e.g.: 0 = no offset, 1 = offset of exact width, 2 = offset of twice the width of the bounding box)"
									}
								},
								"required": [ "offset_x", "offset_y", "offset_z" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:block_in_radius" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"block_condition": {
										"$ref": "#/definitions/conditions/properties/block_condition",
										"description": "The block condition which is applied to the block at the player's feet."
									},
									"radius": {
										"type": "integer",
										"description": "The radius to check blocks in."
									},
									"shape": {
										"description": "Whether to check in a cube- or a star-shaped form. Either \"cube\" or \"star\".",
										"enum": [ "cube", "star" ],
										"default": "cube"
									},
									"comparison": {
										"description": "How to compare the attribute's value to the specified value.",
										"enum": [ "<", "<=", ">", ">=", "==", "!=" ],
										"default": ">="
									},
									"compare_to": {
										"type": "integer",
										"description": "Which value to compare the attribute's value to.",
										"default": 1
									}
								},
								"required": [ "block_condition", "radius" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:brightness" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"comparison": {
										"description": "How to compare the brightness against the specified value.",
										"enum": [ "<", "<=", ">", ">=", "==", "!=" ]
									},
									"compare_to": {
										"type": "number",
										"description": "Which value to compare the brightness against."
									}
								},
								"required": [ "comparison", "compare_to" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:command" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"command": {
										"type": "string",
										"description": "Command to run."
									},
									"comparison": {
										"description": "How to compare the command's result to the specified value.",
										"enum": [ "<", "<=", ">", ">=", "==", "!=" ]
									},
									"compare_to": {
										"type": "integer",
										"description": "Which value to compare the command's result to."
									},
									"permission_level": {
										"type": "integer",
										"description": "[Deprecated since 1.1.0]The permission level to use for the command. 0 is a \"survival player\", anything higher emulates some form of operator. See https://minecraft.fandom.com/wiki/Server.properties#op-permission-level for details.",
										"default": 4,
										"minimum": 0,
										"maximum": 4,
										"deprecated": true
									}
								},
								"required": [ "command", "comparison", "compare_to" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:dimension" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"dimension": {
										"type": "string",
										"description": "ID of the dimension the player needs to be in for this condition to evaluate to true. Vanilla dimensions are minecraft:overworld, minecraft:the_nether and minecraft:the_end, but IDs of custom/modded dimensions should also work.",
										"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$",
										"examples": [ "minecraft:overworld", "minecraft:the_nether", "minecraft:the_end" ]
									}
								},
								"required": [ "dimension" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:enchantment" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"enchantment": {
										"type": "string",
										"description": "ID of the enchantment of interest.",
										"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$",
										"examples": [ "minecraft:protection" ]
									},
									"calculation": {
										"description": "Which number to compare - either the sum of levels of this enchantment on all of the player's equipment, or the max level of this enchantment on any of the player's equipment.",
										"enum": [ "sum", "max" ],
										"default": "sum"
									},
									"comparison": {
										"description": "How the enchantment level should be compared to the specified value.",
										"enum": [ "<", "<=", ">", ">=", "==", "!=" ]
									},
									"compare_to": {
										"type": "integer",
										"description": "The value to compare the enchantment level to."
									}
								},
								"required": [ "enchantment", "comparison", "compare_to" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:entity_group" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"group": {
										"description": "Entity group required for the entity to pass the check. One of default, undead, arthropod, illager and aquatic.",
										"enum": [ "default", "undead", "arthropod", "illager", "aquatic" ]
									}
								},
								"required": [ "group" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:entity_type" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"entity_type": {
										"type": "string",
										"description": "ID of the entity type the entity needs to have to pass the check.",
										"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$",
										"examples": [ "minecraft:creeper" ]
									}
								},
								"required": ["entity_type"]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:equipped_item" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"equipment_slot": {
										"description": "Which equipped item to check. One of: \"mainhand\", \"offhand\", \"head\", \"chest\", \"legs\", \"feet\".",
										"enum": [ "mainhand", "offhand", "head", "chest", "legs", "feet" ]
									},
									"item_condition": {
										"$ref": "#/definitions/conditions/properties/item_condition",
										"description": "Which condition will be applied to the item in the specified slot."
									}
								},
								"required": ["equipment_slot", "item_condition"]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:fall_distance" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"comparison": {
										"description": "How the fall distance should be compared to the specified value.",
										"enum": [ "<", "<=", ">", ">=", "==", "!=" ]
									},
									"compare_to": {
										"type": "number",
										"description": "The value to compare the fall distance to."
									}
								},
								"required": [ "comparison", "compare_to" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:fluid_height" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"fluid": {
										"type": "string",
										"description": "ID of the fluid tag of which the height should be checked.",
										"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$",
										"examples": [ "minecraft:water", "minecraft:lava" ]
									},
									"comparison": {
										"description": "How the fluid height should be compared to the specified value.",
										"enum": [ "<", "<=", ">", ">=", "==", "!=" ]
									},
									"compare_to": {
										"type": "number",
										"description": "Which value the fluid height should be compared to."
									}
								},
								"required": [ "fluid", "comparison", "compare_to" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:food_level" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"comparison": {
										"description": "How the food level should be compared to the specified value.",
										"enum": [ "<", "<=", ">", ">=", "==", "!=" ]
									},
									"compare_to": {
										"type": "number",
										"description": "Which value the food level should be compared to."
									}
								},
								"required": [ "comparison", "compare_to" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:gamemode" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"gamemode": {
										"description": "Name of the gamemode the player should have in order for this condition to evaluate to true.",
										"enum": [ "adventure", "creative", "spectator", "survival" ]
									}
								},
								"required": [ "gamemode" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:health" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"comparison": {
										"description": "How the health of the player should be compared to the specified value.",
										"enum": [ "<", "<=", ">", ">=", "==", "!=" ]
									},
									"compare_to": {
										"type": "number",
										"description": "Which value the health should be compared to."
									}
								},
								"required": [ "comparison", "compare_to" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:in_block_anywhere" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"block_condition": {
										"$ref": "#/definitions/conditions/properties/block_condition",
										"description": "The block condition which blocks need to fulfill in order to count for this power."
									},
									"comparison": {
										"description": "How the number of blocks which overlap and fulfill block_condition should be compared to the specified value.",
										"enum": [ "<", "<=", ">", ">=", "==", "!=" ],
										"default": ">="
									},
									"compare_to": {
										"type": "integer",
										"description": "The value to compare the number to.",
										"default": 1
									}
								},
								"required": [ "block_condition" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:in_block" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"block_condition": {
										"$ref": "#/definitions/conditions/properties/block_condition",
										"description": "The block condition which is applied to the block at the player's lower body half."
									}
								},
								"required": [ "block_condition" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:in_tag" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"tag": {
										"type": "string",
										"description": "ID of the tag the entity type needs to be in to pass the check.",
										"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$",
										"examples": [ "minecraft:skeletons" ]
									}
								},
								"required": [ "tag" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:on_block" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"block_condition": {
										"$ref": "#/definitions/conditions/properties/block_condition",
										"description": "If set, a block that satisfies this block condition needs to be right below the player's feet."
									}
								}
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:origin" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"origin": {
										"type": "string",
										"description": "ID of the origin the player needs to have to pass the check.",
										"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$",
										"examples": [ "origins:human" ]
									},
									"layer": {
										"type": "string",
										"description": "If set, will check only the layer with the provided ID for the origin.",
										"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$",
										"examples": [ "origins:origin" ]
									}
								},
								"required": [ "origin" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "enum": ["origins:passenger_recursive", "origins:passenger"] } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"bientity_condition": {
										"$ref": "#/definitions/conditions/properties/bientity_condition",
										"description": "If specified, it will check for the entity/entities that fulfills the bi-entity condition."
									},
									"comparison": {
										"description": "How the number of entities that are currently riding the entity should be compared to the specified value.",
										"enum": [ "<", "<=", ">", ">=", "==", "!=" ],
										"default": ">="
									},
									"compare_to": {
										"type": "integer",
										"description": "Which value the number of entities currently riding the entity should be compared to.",
										"default": 1
									}
								}
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:power_active" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"power": {
										"type": "string",
										"description": "ID of the power which will be checked for being active.",
										"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$",
										"examples": [ "origins:phantomize" ]
									}
								},
								"required": [ "power" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:power" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"power": {
										"type": "string",
										"description": "ID of the power the player needs to have to pass the check.",
										"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$",
										"examples": [ "origins:phantomize" ]
									}
								},
								"required": [ "power" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:predicate" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"predicate": {
										"type": "string",
										"description": "ID of the predicate the entity needs to pass.\nNote: due to the nature of predicates, this condition is only effective on the server-side.",
										"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$"
									}
								},
								"required": [ "predicate" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:relative_health" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"comparison": {
										"description": "How the relative health of the player should be compared to the specified value.",
										"enum": [ "<", "<=", ">", ">=", "==", "!=" ]
									},
									"compare_to": {
										"type": "number",
										"description": "Which value the relative health should be compared to."
									}
								},
								"required": [ "comparison", "compare_to" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:resource" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"resource": {
										"type": "string",
										"description": "ID of the power type that defines the resource. Must be a Resource (Power Type) which exists on the player.",
										"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$"
									},
									"comparison": {
										"description": "How the resource should be compared to the specified value.",
										"enum": [ "<", "<=", ">", ">=", "==", "!=" ]
									},
									"compare_to": {
										"type": "integer",
										"description": "Which value the resource should be compared to."
									}
								},
								"required": [ "resource", "comparison", "compare_to" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:riding_recursive" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"bientity_condition": {
										"$ref": "#/definitions/conditions/properties/bientity_condition",
										"description": "If specified, it will check for the entity/entities that fulfills the bi-entity condition."
									},
									"comparison": {
										"description": "How the number of entities that are currently riding the entity should be compared to the specified value.",
										"enum": [ "<", "<=", ">", ">=", "==", "!=" ],
										"default": ">="
									},
									"compare_to": {
										"type": "integer",
										"description": "Which value the number of entities currently riding the entity should be compared to.",
										"default": 1
									}
								}
							}
						},
						{
							"if": {
								"properties": { "type": { "enum": ["origins:riding_root", "origins:riding"] } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"bientity_condition": {
										"$ref": "#/definitions/conditions/properties/bientity_condition",
										"description": "If specified, it will only check for the entity/entities that fulfills the bi-entity condition."
									}
								}
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:saturation_level" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"comparison": {
										"description": "How the saturation level should be compared to the specified value.",
										"enum": [ "<", "<=", ">", ">=", "==", "!=" ]
									},
									"compare_to": {
										"type": "number",
										"description": "Which value the saturation level should be compared to."
									}
								},
								"required": [ "comparison", "compare_to" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:scoreboard" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"objective": {
										"type": "string",
										"description": "The name of the scoreboard objective to retrieve the value from and compare.\nDue to the nature of scoreboards, this condition is only effective on the server-side.\nIf the entity does not have the scoreboard objective, this condition always returns false."
									},
									"comparison": {
										"description": "How to compare the objective's value to the specified value.",
										"enum": [ "<", "<=", ">", ">=", "==", "!=" ]
									},
									"compare_to": {
										"type": "integer",
										"description": "Which value to compare the objective's value to."
									}
								},
								"required": [ "objective", "comparison", "compare_to" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:status_effect" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"effect": {
										"type": "string",
										"description": "ID of the status effect the player should have.",
										"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$"
									},
									"min_amplifier": {
										"type": "integer",
										"description": "The minimum amplifier the status effect should have in order to pass the check.",
										"default": 0,
										"maximum": 2147483647
									},
									"max_amplifier": {
										"type": "integer",
										"description": "The maximum amplifier the status effect should have in order to pass the check.",
										"default": 2147483647,
										"maximum": 2147483647
									},
									"min_duration": {
										"type": "integer",
										"description": "The minimum duration in ticks the status effect should have left in order to pass the check.",
										"default": 0,
										"minimum": 0,
										"maximum": 2147483647
									},
									"max_duration": {
										"type": "integer",
										"description": "The maximum duration in ticks the status effect should have left in order to pass the check.",
										"default": 2147483647,
										"minimum": 0,
										"maximum": 2147483647
									}
								},
								"required": [ "effect" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:submerged_in" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"fluid": {
										"type": "string",
										"description": "ID of the fluid tag that should be checked.",
										"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$",
										"examples": [ "minecraft:water", "minecraft:lava" ]
									}
								},
								"required": [ "fluid" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:using_item" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"item_condition": {
										"$ref": "#/definitions/conditions/properties/item_condition",
										"description": "If specified, the condition will only pass if the item that is being used fulfills this condition."
									}
								}
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:xp_levels" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"comparison": {
										"description": "How the experience level of the player should be compared to the specified value.",
										"enum": [ "<", "<=", ">", ">=", "==", "!=" ]
									},
									"compare_to": {
										"type": "integer",
										"description": "Which value the experience level should be compared to."
									}
								},
								"required": [ "comparison", "compare_to" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:xp_points" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"comparison": {
										"description": "How the experience points of the player should be compared to the specified value.",
										"enum": [ "<", "<=", ">", ">=", "==", "!=" ]
									},
									"compare_to": {
										"type": "integer",
										"description": "Which value the experience points should be compared to."
									}
								},
								"required": [ "comparison", "compare_to" ]
							}
						}
					]
				},
				"fluid_condition": {
					"type": "object",
					"description": "Fluid Conditions operate on a FluidState, essentially which fluid (if any) exists, as well as properties of the fluid.",
					"properties": {
						"type": {
							"type": "string",
							"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$",
							"examples": [
								"origins:and", "origins:or", "origins:constant",
								"origins:empty", "origins:in_tag", "origins:stil"
							]
						},
						"inverted": {
							"type": "boolean",
							"description": "If true, the condition acts inverted.",
							"default": false
						}
					},
					"required": [ "type" ],
					"allOf": [
						{
							"$comment": "#region meta",
							"if": {
								"properties": { "type": { "const": "origins:and" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"conditions": {
										"type": "array",
										"description": "All of these conditions have to be fulfilled in order for this condition to be fulfilled.",
										"items": { "$ref": "#/definitions/conditions/properties/fluid_condition" },
										"minItems": 1
									}
								},
								"required": [ "conditions" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:or" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"conditions": {
										"type": "array",
										"description": "Any of these conditions have to be fulfilled in order for this condition to be fulfilled.",
										"items": { "$ref": "#/definitions/conditions/properties/fluid_condition" },
										"minItems": 1
									}
								},
								"required": [ "conditions" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:constant" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"value": {
										"type": "boolean",
										"description": "If true, the condition is always fulfilled. If false, the condition is never fulfilled."
									}
								},
								"required": [ "value" ]
							},
							"$comment": "#endregion meta"
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:in_tag" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"tag": {
										"type": "string",
										"description": "ID of the tag which the fluid should be in to pass the check.",
										"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$",
										"examples": [ "minecraft:water" ]
									}
								},
								"required": [ "tag" ]
							}
						}
					]
				},
				"item_condition": {
					"type": "object",
					"description": "Item Conditions operate on an ItemStack.",
					"properties": {
						"type": {
							"type": "string",
							"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$",
							"examples": [
								"origins:and", "origins:or", "origins:constant",
								"origins:amount", "origins:armor_value", "origins:empty", "origins:enchantment", "origins:fireproof",
								"origins:food", "origins:harvest_level", "origins:ingredient", "origins:meat", "origins:nbt"
							]
						},
						"inverted": {
							"type": "boolean",
							"description": "If true, the condition acts inverted.",
							"default": false
						}
					},
					"required": [ "type" ],
					"allOf": [
						{
							"$comment": "#region meta",
							"if": {
								"properties": { "type": { "const": "origins:and" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"conditions": {
										"type": "array",
										"description": "All of these conditions have to be fulfilled in order for this condition to be fulfilled.",
										"items": { "$ref": "#/definitions/conditions/properties/item_condition" },
										"minItems": 1
									}
								},
								"required": [ "conditions" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:or" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"conditions": {
										"type": "array",
										"description": "Any of these conditions have to be fulfilled in order for this condition to be fulfilled.",
										"items": { "$ref": "#/definitions/conditions/properties/item_condition" },
										"minItems": 1
									}
								},
								"required": [ "conditions" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:constant" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"value": {
										"type": "boolean",
										"description": "If true, the condition is always fulfilled. If false, the condition is never fulfilled."
									}
								},
								"required": ["value"]
							},
							"$comment": "#endregion meta"
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:amount" } },
								"require": [ "type" ]
							},
							"then": {
								"properties": {
									"comparison": {
										"description": "Determines how to compare the number of items in this stack to the specified value.",
										"enum": [ "<", "<=", ">", ">=", "==", "!=" ]
									},
									"compare_to": {
										"type": "integer",
										"description": "Which value to compare the item's count value to."
									}
								},
								"required": [ "comparison", "compare_to" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:armor_value" } },
								"require": [ "type" ]
							},
							"then": {
								"properties": {
									"comparison": {
										"description": "How to compare the item's armor value to the specified value.",
										"enum": [ "<", "<=", ">", ">=", "==", "!=" ]
									},
									"compare_to": {
										"type": "integer",
										"description": "Which value to compare the item's armor value to."
									}
								},
								"required": [ "comparison", "compare_to" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:enchantment" } },
								"require": [ "type" ]
							},
							"then": {
								"properties": {
									"enchantment": {
										"type": "string",
										"description": "ID of the enchantment of interest.",
										"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$",
										"examples": [ "minecraft:fortune" ]
									},
									"comparison": {
										"description": "How to compare the enchantment level the specified value.",
										"enum": [ "<", "<=", ">", ">=", "==", "!=" ]
										
									},
									"compare_to": {
										"type": "integer",
										"description": "Which value to compare the enchantment level against."
									}
								},
								"required": [ "comparison", "compare_to" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:harvest_level" } },
								"require": [ "type" ]
							},
							"then": {
								"properties": {
									"comparison": {
										"description": "How to compare the item's harvest level to the specified value.",
										"enum": [ "<", "<=", ">", ">=", "==", "!=" ]
										
									},
									"compare_to": {
										"type": "integer",
										"description": "Which value to compare the item's harvest level to."
									}
								},
								"required": [ "comparison", "compare_to" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:ingredient" } },
								"require": [ "type" ]
							},
							"then": {
								"properties": {
									"ingredient": {
										"$ref": "#/definitions/origins_data_types/properties/ingredient",
										"description": "The ingredient this item must match to pass the check."
									}
								},
								"required": [ "ingredient" ]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "origins:nbt" } },
								"require": [ "type" ]
							},
							"then": {
								"properties": {
									"nbt": {
										"type": "string",
										"description": "The NBT data to check for.",
										"examples": ["{exampleCustomTag: 1b}"]
									}
								},
								"required": [ "ingredient" ]
							}
						}
					]
				}
			}
		},
		"origins_data_types": {
			"type": "object",
			"description": "Group for https://origins.readthedocs.io/en/latest/data_types/",
			"$comment": "As Comparison and Modifier Operation are basicaly just enum's and badges are only used once they are not included in this list.",
			"properties": {
				"modifier": {
					"type": "object",
					"description": "An Object used to specify how a value should be modified.",
					"properties": {
						"operation": {
							"description": "The operation which will be performed by this modifier.",
							"enum": ["addition", "multiply_base", "multiply_total"]
						},
						"value": {
							"type": "number",
							"description": "The value with which to apply the operation to the value."
						},
						"name": {
							"type": "string",
							"description": "A descriptive name for the modifier, describing where it comes from."
						}
					},
					"required": [ "operation", "value" ]
				},
				"attributed_modifier": {
					"type": "object",
					"description": "An Object used to specify how a specific attribute should be modified. Basically an Attribute Modifier with an additional attribute field.",
					"properties": {
						"attribute": {
							"type": "string",
							"description": "ID of the attribute which will be modified by this modifier.",
							"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$",
							"examples": [ "minecraft:generic.attack_speed" ]
						},
						"operation": {
							"description": "The operation which will be performed by this modifier.",
							"enum": [ "addition", "multiply_base", "multiply_total" ]
						},
						"value": {
							"type": "number",
							"description": "The value with which to apply the operation to the value."
						},
						"name": {
							"type": "string",
							"description": "A descriptive name for the modifier, describing where it comes from."
						}
					},
					"required": [ "attribute", "operation", "value" ]
				},
				"crafting_recipe": {
					"type": "object",
					"description": "An Object specifying a shapeless or shaped crafting recipe. For some more information, see: https://minecraft.gamepedia.com/Recipe",
					"properties": {
						"type": {
							"description": "The type of recipe. Either minecraft:crafting_shaped or minecraft:crafting_shapeless. Other recipe types are not supported.",
							"enum": ["minecraft:crafting_shaped", "minecraft:crafting_shapeless"]
						},
						"id": {
							"type": "string",
							"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$",
							"description": "An ID for this recipe. Has to be unique among all recipes, otherwise there will be a conflict."
						},
						"result": {
							"type": "object",
							"description": "The result of the crafting. Note that vanilla does not support NBT tags in the result.",
							"properties": {
								"item": {
									"type": "string",
									"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$"
								},
								"count": {
									"type": "integer"
								}
							},
							"required": ["item", "count"],
							"additionalProperties": false
						}
					},
					"required": ["type", "id", "result" ],
					"additionalProperties": false,
					"allOf": [
						{
							"if": {
								"properties": { "type": { "const": "minecraft:crafting_shapeless" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"ingredients": {
										"type": "array",
										"description": "These items need to be put in the crafting grid for the recipe.",
										"items": {"$ref": "#/definitions/origins_data_types/properties/ingredient"},
										"uniqueItems": false,
										"minItems": 1
									}
								},
								"required": ["ingredients"]
							}
						},
						{
							"if": {
								"properties": { "type": { "const": "minecraft:crafting_shaped" } },
								"required": [ "type" ]
							},
							"then": {
								"properties": {
									"pattern": {
										"$comment": "As some mods add crafting tables with larger than 3 by 3 grids I've not added a maxItems restiction",
										"type": "array",
										"description": "Specifies the pattern, with each element representing one row. Use a single character to describe one item. A space means that position is empty.",
										"items": {
											"type": "string"
										},
										"minItems": 1
									},
									"key": {
										"type": "object",
										"patternProperties": {
											"^[^\\ ]$": {"$ref": "#/definitions/origins_data_types/properties/ingredient"}
										},
										"minProperties": 1
									}
								},
								"required": ["pattern", "key"]
							}
						}
					]
				},
				"damage_source": {
					"type": "object",
					"description": "An Object used to specify how to deal damage to an entity.",
					"properties": {
						"name": {
							"type": "string",
							"description": "The name of the damage source. Controls death message as well as other interactions. Consider https://origins.readthedocs.io/en/latest/misc/vanilla_damage_sources/ when picking a name.",
							"examples": [
								"anvil", "arrow", "badRespawnPoint", "cactus", "cramming",
								"dragonBreath", "drown", "dryout", "explosion.player",
								"explosion", "fall", "fallingBlock", "fallingStalactite",
								"fireworks", "flyIntoWall", "freeze", "generic", "hotFloor",
								"indirectMagic", "inFire", "inWall", "lava", "lightningBolt",
								"magic", "mob", "onFire", "outOfWorld", "player", "stalagmite",
								"starve", "sting", "sweetBerryBush", "thorns", "thrown",
								"trident", "wither", "witherSkull"
							]
						},
						"bypasses_armor": {
							"type": "boolean",
							"description": "When true, armor values are not taken into account when calculating the actual damage amount taken.",
							"default": false
						},
						"fire": {
							"type": "boolean",
							"description": "When true, the damage will be considered fire damage.",
							"default": false
						},
						"unblockable": {
							"type": "boolean",
							"description": "When true, the damage will be unblockable (not reduced by resistance effects or protection enchantments).",
							"default": false
						},
						"magic": {
							"type": "boolean",
							"description": "When true, the damage will be considered magic damage.",
							"default": false
						},
						"out_of_world": {
							"type": "boolean",
							"description": "When true, the damage will be considered \"out of world\" damage, i.e. damage from falling into the void.",
							"default": false
						}
					},
					"required": [ "name" ],
					"additionalProperties": false
				},
				"hud_render": {
					"type": "object",
					"description": "An Object used to define how a resource or cooldown bar should be rendered.",
					"properties": {
						"should_render": {
							"type": "boolean",
							"description": "Whether the bar should be visible or not.",
							"default": true
						},
						"sprite_location": {
							"type": "string",
							"description": "The path to the file in the assets which contains what the bar looks like. See https://origins.readthedocs.io/en/latest/misc/resource_bars/ for a list of files included by default in the mod.",
							"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$",
							"default": "origins:textures/gui/resource_bar.png",
							"examples": [
								"origins:textures/gui/resource_bar.png",
								"origins:textures/gui/community/spiderkolo/resource_bar_01.png",
								"origins:textures/gui/community/spiderkolo/resource_bar_02.png",
								"origins:textures/gui/community/spiderkolo/resource_bar_03.png",
								"origins:textures/gui/community/spiderkolo/resource_bar_points_01.png",
								"origins:textures/gui/community/huang/resource_bar_01.png",
								"origins:textures/gui/community/huang/resource_bar_02.png"
							]
						},
						"bar_index": {
							"type": "integer",
							"description": "The indexed position of the bar on the sprite to use. Please note that indexes start at 0.",
							"default": 0,
							"minimum": 0
						},
						"condition": {
							"$ref": "#/definitions/conditions/properties/entity_condition",
							"description": "If set (and should_render is true), the bar will only display when the entity with the power fulfills this condition."
						}
					}
				},
				"ingredient": {
					"type": ["object", "array"],
					"description": "Either: an Object specifying a registered item or item tag. Or: an Array of Objects specifying a registered item or item tag.",
					"items": {
						"type": "object",
						"properties": {
							"item": {
								"type": "string",
								"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$",
								"description": "ID of a registered item."
							},
							"tag": {
								"type": "string",
								"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$",
								"description": "ID of an item tag. Will be ignored if item is set."
							}
						},
						"anyOf": [
							{"required": ["item"]},
							{"required": ["tag"]}
						]
					},
					"properties": {
						"item": {
							"type": "string",
							"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$",
							"description": "ID of a registered item."
						},
						"tag": {
							"type": "string",
							"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$",
							"description": "ID of an item tag. Will be ignored if item is set."
						}
					},
					"additionalProperties": false,
					"anyOf": [
						{"required": ["item"]},
						{"required": ["tag"]},
						{"minItems": 2}
					]
				},
				"item_stack": {
					"type": "object",
					"description": "An Object which defines a new item stack.",
					"properties": {
						"item": {
							"type": "string",
							"description": "ID of a registered item.",
							"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$"
						},
						"amount": {
							"type": "integer",
							"description": "Size of the stack.",
							"default": 1,
							"minimum": 1
						},
						"tag": {
							"$comment": "Is there a better pattern for NBT data?",
							"type": "string",
							"description": "NBT data of the item.",
							"pattern": "\\{.*\\:.*\\}"
						}
					},
					"required": ["item"],
					"additionalProperties": false
				},
				"key": {
					"type": "object",
					"description": "An Object which defines a keybinding, used in active powers to define which key they react to.",
					"properties": {
						"key": {
							"type": "string",
							"description": "A string specifying the keybinding. See https://origins.readthedocs.io/en/latest/misc/keybindings/ for possible values.",
							"pattern": "^[a-z0-9\\-\\_\\.]+$",
							"examples": [ "key.origins.primary_active", "key.origins.secondary_active" ]
						},
						"continuous": {
							"type": "boolean",
							"description": "Whether the keybinding should only trigger the power on the first tick the key is held down, or, if set to true, continuously on each tick while the key is held.",
							"default": false
						}
					},
					"required": [ "key" ],
					"additionalProperties": false
				},
				"positioned_item_stack": {
					"type": "object",
					"description": "An Object which defines a new item stack alongside a position in an inventory. Basically an Item Stack with a slot field.",
					"properties": {
						"item": {
							"type": "string",
							"description": "ID of a registered item.",
							"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$"
						},
						"amount": {
							"type":"integer",
							"description": "Size of the stack.",
							"default": 1,
							"minimum": 1
						},
						"tag": {
							"$comment": "Is there a better pattern for NBT data?",
							"type": "string",
							"description": "NBT data of the item.",
							"pattern": "\\{.*\\:.*\\}"
						},
						"slot": {
							"$comment": "Because certian mods add inventory slots I've not specified a maximum",
							"type": "integer",
							"description": "Inventory slot position of the stack. If not specified, will be the first free slot in the inventory. See https://origins.readthedocs.io/en/latest/misc/positioned_item_stack_slots/ for possible values",
							"minimum": 0
						}
					},
					"required": ["item"],
					"additionalProperties": false
				},
				"status_effect_instance": {
					"type": "object",
					"properties": {
						"effect": {
							"type": "string",
							"description": "ID of the status effect.",
							"pattern": "^([a-z0-9\\-\\_\\.]+\\:)?[a-z0-9\\-\\_\\.\\/]+$",
							"examples": ["minecraft:slowness"]
						},
						"duration": {
							"type": "integer",
							"description": "Duration of the status effect in ticks.",
							"default": 100,
							"minimum": 1
						},
						"amplifier": {
							"type": "integer",
							"description": "Amplifier of the status effect.",
							"default": 0
						},
						"is_ambient": {
							"type": "boolean",
							"description": "Whether the effect counts as an ambient effect.",
							"default": false
						},
						"show_particles": {
							"type": "boolean",
							"description": "Whether the status effect will spawn particles on the player.",
							"default": true
						},
						"show_icon": {
							"type": "boolean",
							"description": "Whether the status effect will show an icon on the HUD.",
							"default": true
						}
					},
					"required": ["effect"],
					"additionalProperties": false
				}
			}
		}
	}
}